[{"id":0,"href":"/SwiftPHP/guides/","title":"Guides","section":"Hello Swift","content":"This is the main landing page for the guides section.\n"},{"id":1,"href":"/SwiftPHP/guides/installation/","title":"Installtion Guide","section":"Guides","content":"Installation Guide# As of writing, this is designed for PHP 8.4 support.\nInstalling on macOS# macOS is straight forward but requires brew and xcode installed.\nxcode-select --install /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; # Build PHP.xcframework to compile extensions against ./Scripts/build_xcframework.sh # Build PHP CLI to test your extension with ./Scripts/build_macos.shInstallation on Windows 11 x64/ARM64# As of this time, the current Windows SDK is broken and you need to follow the guide to install Swift on Windows successfully https://forums.swift.org/t/an-unofficial-guide-to-building-the-swift-toolchain-on-windows-x64-and-arm64/81751\nWindows 11 ARM64# PHP has no official support for Windows 11 on ARM, however progress is being made and you can use the guide below.\nDownload the experimental builds for PHP 8.4: https://github.com/hyh19962008/php-windows-arm64/releases/download/8.4.10/php-8.4.10-nts-Win32-vs17-arm64-experimental.7z. Source code and SDK are in the same 7zip file. php-8.4.10-nts-Win32-vs17-arm64-experimental.7z Edit Scripts/win_ext.ps1 and change $env:PHP_SRC_ROOT=\u0026quot;D:/dev/php-src-php-8.4.10\u0026quot; to where the PHP source code was unzipped to. # Change these to where you decompressed `php-8.4.10-nts-Win32-vs17-arm64-experimental` $env:PHP_SRC_ROOT = \u0026#34;D:/dev/php-8.4.10-nts-Win32-vs17-arm64-experimental/SDK/include\u0026#34; $env:PHP_LIB_ROOT = \u0026#34;D:/dev/php-8.4.10-nts-Win32-vs17-arm64-experimental/SDK/lib\u0026#34; Run Scripts/win_ext.ps1 to build your Native PHP extension. "},{"id":2,"href":"/SwiftPHP/guides/performance/","title":"Performance Comparison","section":"Guides","content":"Performance Comparison# Swift offers great performance since its a compiled language with parallel and async features that are type checked. All while having no garbage collection.\nBenchmark Pairwise Distance# Pairwise Distance calculates the distance between every unique pair of vectors\n$$d = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2 + (z_2 - z_1)^2}$$\nResult (Debug Mode)# The following is based on 50,000 vectors and ~1.25 billion calcuations.\nVersion Processor / OS Execution Time Estimated Time at 50 k Vectors Speedup vs PHP PHP (Baseline) Apple M4 Mac mini (macOS 15) 953.98 s ~15.9 minutes 1Ã— Swift (Single Core) Apple M4 Mac mini (macOS 15) 8.2841 s 8.2841 s ~115.16Ã— Swift (Multi-Core) Apple M4 Mac mini (macOS 15) 2.1486 s 2.1486 s ~444.00Ã— PHP (Baseline) Snapdragon X1P42100 (Windows 11) 1.2340 s ~12.9 minutes 1Ã— Swift (Single Core) Snapdragon X1P42100 (Windows 11) 11.0950 s 11.0950 s ~68.35Ã— Swift (Multi-Core) Snapdragon X1P42100 (Windows 11) 3.0551 s 3.0551 s ~252.45Ã— PHP Benchmark Test# $numVectors = 50_000; echo \u0026#34;Generating test data...\\n\u0026#34;; $vectors = []; for ($i = 0; $i \u0026lt; $numVectors; $i++) { $vectors[] = new \\raylib\\Vector3( rand(0, 100) / 10.0, rand(0, 100) / 10.0, rand(0, 100) / 10.0 ); } echo \u0026#34;Test data generated.\\n\\n\u0026#34;; $smallVectorSet = array_slice($vectors, 0, 2000); printf(\u0026#34;\\n--- Benchmarking Pairwise Distance ---\\n\u0026#34;); printf(\u0026#34;Running PHP version with %s vectors...\\n\u0026#34;, number_format(count($smallVectorSet))); $startPhp = microtime(true); $phpDistance = php_total_pairwise_distance($smallVectorSet); $endPhp = microtime(true); $phpTime = $endPhp - $startPhp; printf(\u0026#34;PHP Time: %.4f seconds\\n\u0026#34;, $phpTime); printf(\u0026#34;\\nRunning Swift version with %s vectors...\\n\u0026#34;, number_format(count($vectors))); $startSwift = microtime(true); $swiftDistance = \\raylib\\total_pairwise_distance($vectors); // Your new namespaced function $endSwift = microtime(true); $swiftTime = $endSwift - $startSwift; printf(\u0026#34;Swift Time: %.4f seconds\\n\u0026#34;, $swiftTime); $speedup = ($phpTime / count($smallVectorSet)**2) / ($swiftTime / count($vectors)**2); printf(\u0026#34;\\nâœ… Swift extension is roughly %.2f times faster on a per-operation basis.\\n\u0026#34;, $speedup);Pure PHP Implementation# PHP has no built-in threading or parallel features to speed this up.\n/** * Calculates the sum of the distances between every unique * pair of vectors in the array. This is an O(n^2) operation. */ function php_total_pairwise_distance(array $vectors): float { $totalDistance = 0.0; $count = count($vectors); for ($i = 0; $i \u0026lt; $count; $i++) { for ($j = $i + 1; $j \u0026lt; $count; $j++) { $dx = $vectors[$i]-\u0026gt;x - $vectors[$j]-\u0026gt;x; $dy = $vectors[$i]-\u0026gt;y - $vectors[$j]-\u0026gt;y; $dz = $vectors[$i]-\u0026gt;z - $vectors[$j]-\u0026gt;z; $totalDistance += sqrt($dx * $dx + $dy * $dy + $dz * $dz); } } return $totalDistance; }SwiftPHP Native PHP Extension Implementation# /** * A highly optimized function to distribute N items into P parts as evenly as possible. * * Why `@inline(__always)`? * This is an aggressive compiler optimization directive. It tells the compiler to * copy and paste the machine code for this function directly into the place * where it\u0026#39;s called, rather than making a traditional function call. This eliminates * the tiny but measurable overhead of setting up a function call (pushing arguments * onto the stack, jumping to a new memory address, and returning). For a small, * frequently-called function like this, inlining provides a speed boost. */ @inline(__always) private func chunkBounds(count: Int, parts: Int, index: Int) -\u0026gt; Range\u0026lt;Int\u0026gt; { // Why this math? This is a classic, highly efficient way to partition work. // It avoids floating-point math and ensures perfect distribution. // `base`: The minimum number of items each part will handle. // e.g., 100 items / 8 parts = 12. Each part gets at least 12. let base = count / parts // `rem`: The number of \u0026#34;leftover\u0026#34; items that need to be distributed. // e.g., 100 % 8 = 4. There are 4 extra items to hand out. let rem = count % parts // `start`: The starting index for the current part (`index`). // Each part gets `index * base` items from the base distribution. // `min(index, rem)` is the clever part: it gives one extra \u0026#34;leftover\u0026#34; item // to each of the first `rem` parts. // e.g., part 3 (index=3) gets 3*12 + min(3, 4) = 36 + 3 = 39. let start = index * base + min(index, rem) // `end`: The exclusive ending index. // It\u0026#39;s the `start` plus the `base` size, plus 1 if this part is one of the // first `rem` parts that received an extra item. This ensures the range // has the correct length. let end = start + base + (index \u0026lt; rem ? 1 : 0) return start..\u0026lt;end } /** * A simple, raw pointer container. * * Why a struct? * Structs are value types in Swift, meaning they are typically stack-allocated * and copied on assignment. This makes them very fast and lightweight. Here, it\u0026#39;s * just a thin wrapper around a raw pointer. * * Why `@unchecked Sendable`? * This is a promise to the compiler that we, the developers, guarantee this type * is safe to use across concurrent threads. We can make this promise because we * know each thread will only ever write to its own unique index (`partials.base[part]`), * so there will be no data races. This bypasses compiler safety checks for a * performance gain. * * Why `UnsafeMutablePointer`? * This is the \u0026#34;bare metal\u0026#34; way to access memory in Swift. It\u0026#39;s a raw memory * address, similar to a `double*` in C. It provides maximum performance by * bypassing all of Swift\u0026#39;s safety features: * - No automatic reference counting (ARC). * - No bounds checking on access. * - No memory lifetime management. * We are responsible for allocating, initializing, and deallocating the memory manually. */ private struct Partials: @unchecked Sendable { let base: UnsafeMutablePointer\u0026lt;Double\u0026gt; } /** * Calculates the total pairwise distance using a low-level, highly optimized parallel approach. */ func calculateTotalPairwiseDistanceParallel(_ vectors: [Vector3]) -\u0026gt; Double { let n = vectors.count if n \u0026lt; 2 { return 0 } // Why `max(1, ...)`? A simple guard to prevent dividing by zero if the system // somehow reported zero cores. let cores = max(1, ProcessInfo.processInfo.activeProcessorCount) // Why `min(cores, n)`? An optimization to avoid creating more threads than // there are items to process in the outer loop, which would be wasteful. let parts = min(cores, n) // --- Manual Memory Management --- // 1. Allocate: We ask the system for a raw, uninitialized block of memory // large enough to hold a `Double` for each parallel part. let ptr = UnsafeMutablePointer\u0026lt;Double\u0026gt;.allocate(capacity: parts) // 2. Initialize: We explicitly set the allocated memory to a known state (all zeros). // Accessing uninitialized memory is undefined behavior. ptr.initialize(repeating: 0, count: parts) // Create our thin wrapper around the raw pointer. let partials = Partials(base: ptr) // Why `DispatchQueue.concurrentPerform`? // This is the star of the show. It\u0026#39;s a highly optimized GCD function // specifically for \u0026#34;fork-join\u0026#34; parallelism. It executes the code in its closure // `iterations` times, distributing those executions across all available CPU // cores. Crucially, it is a *blocking* call: this line of code will not // finish and the function will not proceed until all `parts` have completed. // This avoids the massive overhead of an async-to-sync bridge (like a DispatchSemaphore). DispatchQueue.concurrentPerform(iterations: parts) { part in // `part` is the current iteration index (0, 1, 2, ...) // Each thread calculates its assigned range of the outer loop. let r = chunkBounds(count: n, parts: parts, index: part) // Why `local`? This is a critical performance pattern. Each thread accumulates // its own sub-total in a variable that is local to its own stack. This means // there is zero lock contention or synchronization needed during the main calculation. var local: Double = 0 var i = r.lowerBound while i \u0026lt; r.upperBound { let a = vectors[i] // The inner loop still has to go to the end of the array. The parallelism // is only applied to the outer loop. var j = i + 1 while j \u0026lt; n { let b = vectors[j] let dx = a.x - b.x let dy = a.y - b.y let dz = a.z - b.z // `squareRoot()` on a `Double` is often faster than the global `sqrt()` function. local += (dx*dx + dy*dy + dz*dz).squareRoot() j += 1 } i += 1 } // After all calculations are done, each thread performs a single, // uncontested write to its designated slot in the shared memory block. // e.g., thread 0 writes to base[0], thread 1 writes to base[1], etc. // Since no two threads write to the same index, no locks are needed. partials.base[part] = local } // --- Final Summation and Cleanup --- // At this point, `concurrentPerform` has finished and all threads have completed. // The `partials.base` pointer now holds all the sub-totals. var total: Double = 0 for i in 0..\u0026lt;parts { total += partials.base[i] } // 3. Deinitialize: We tell Swift that we are done with the values in this memory. // This is important for types that might have their own cleanup code. For `Double`, // it\u0026#39;s less critical but is correct and required practice. partials.base.deinitialize(count: parts) // 4. Deallocate: We return the raw memory block back to the system to prevent a memory leak. partials.base.deallocate() return total } // The PHP C-interop code remains the same, as its job is to prepare the native // Swift array and then call the calculation function. @MainActor public let arginfo_total_pairwise_distance: [zend_internal_arg_info] = [ ZEND_BEGIN_ARG_INFO_EX(name: \u0026#34;total_pairwise_distance\u0026#34;, return_reference: false, required_num_args: 1), ZEND_ARG_INFO(pass_by_ref: false, name: \u0026#34;vectors\u0026#34;) ] @_cdecl(\u0026#34;zif_total_pairwise_distance\u0026#34;) public func zif_total_pairwise_distance( _ execute_data: UnsafeMutablePointer\u0026lt;zend_execute_data\u0026gt;?, _ return_value: UnsafeMutablePointer\u0026lt;zval\u0026gt;? ) { var vectorsParam: UnsafeMutablePointer\u0026lt;zval\u0026gt;? = nil guard let return_value = return_value else { return } do { guard var state = ZEND_PARSE_PARAMETERS_START(min: 1, max: 1, execute_data: execute_data) else { return } try Z_PARAM_ARRAY(state: \u0026amp;state, dest: \u0026amp;vectorsParam) try ZEND_PARSE_PARAMETERS_END(state: state) } catch { return } guard let vectorsArrayZval = vectorsParam, let vector3_ce = V3State.shared.ce else { return } var nativeVectors: [Vector3] = [] let ht = Z_ARRVAL_P(vectorsArrayZval) let expectedCount = Int(zend_hash_num_elements(ht)) nativeVectors.reserveCapacity(expectedCount) ZEND_HASH_FOREACH_VAL(ht) { zv in var tmp = zval() ZVAL_COPY_DEREF(\u0026amp;tmp, zv) defer { zval_ptr_dtor(\u0026amp;tmp) } if Z_TYPE(tmp) == IS_OBJECT \u0026amp;\u0026amp; Z_OBJCE(tmp) == vector3_ce { let intern = fetchObject(Z_OBJ(tmp)) nativeVectors.append(intern.pointee.vector3) } } // This is a direct, synchronous call. The function blocks until the parallel // work is done and then returns the final result. No bridging is needed. let finalDistance = calculateTotalPairwiseDistanceParallel(nativeVectors) RETURN_DOUBLE(return_value, finalDistance) }"},{"id":3,"href":"/SwiftPHP/guides/arrays/","title":"PHP Arrays In Swift","section":"Guides","content":"Working with PHP Arrays in Swift ðŸš€# This guide explains how to use a set of helper methods to safely iterate over PHP arrays in Swift. These methods are provided as an extension on UnsafeMutablePointer\u0026lt;zend_array\u0026gt;, which means you can call them directly on the result of Z_ARRVAL_P(...).\nThe goal is to provide a simple, type-safe, and idiomatic Swift interface that handles the complex C-level boilerplate for you.\nPrerequisites: The ZendObjectContainer Protocol# Before you can iterate over your custom PHP objects, the Swift struct that defines its memory layout must conform to the ZendObjectContainer protocol. This is essential for the helper functions to correctly calculate memory offsets.\n1. The Protocol Definition This protocol should be available in your project.\npublic protocol ZendObjectContainer { var std: zend_object { get set } static var stdOffset: Int { get } }2. Example Conformance For your custom object struct, ensure std is a stored property and add the conformance in an extension.\n// The struct that matches your PHP object\u0026#39;s memory layout @frozen public struct MyPHPObject { var myCustomData: String public var std: zend_object // Must be a stored property } // Add conformance in an extension extension MyPHPObject: ZendObjectContainer { public static var stdOffset: Int { MemoryLayout\u0026lt;Self\u0026gt;.offset(of: \\.std)! } } Iterating Over Values Only# These methods are for when you only care about the values in an array and not their keys.\nwithEachObject# Iterates over the array and yields only the elements that are objects of a specific class.\nSignature:\nfunc withEachObject\u0026lt;T: ZendObjectContainer\u0026gt;( ofType ce: UnsafeMutablePointer\u0026lt;zend_class_entry\u0026gt;?, as objectType: T.Type, body: (UnsafeMutablePointer\u0026lt;T\u0026gt;) -\u0026gt; Void )Example:\nvar nativeObjects: [MyPHPObject] = [] let ht = Z_ARRVAL_P(phpArrayZval) let myClassEntry = MyState.shared.ce // Get your class entry ht.withEachObject(ofType: myClassEntry, as: MyPHPObject.self) { intern in // \u0026#39;intern\u0026#39; is a correctly typed pointer to your Swift struct nativeObjects.append(intern.pointee) } withEachString, withEachInt, withEachDouble# Iterates over the array, yielding only the values that match a specific scalar type.\nSignatures:\nfunc withEachString(body: (String) -\u0026gt; Void) func withEachInt(body: (Int) -\u0026gt; Void) func withEachDouble(body: (Double) -\u0026gt; Void)Example:\nvar names: [String] = [] let ht = Z_ARRVAL_P(phpArrayZval) ht.withEachString { name in names.append(name) } forEach (Value-Only)# The \u0026ldquo;power-user\u0026rdquo; iterator. It yields a pointer to every zval in the array, leaving type checking up to you.\nSignature:\nfunc forEach(body: (UnsafeMutablePointer\u0026lt;zval\u0026gt;) -\u0026gt; Void)Example:\nlet ht = Z_ARRVAL_P(phpArrayZval) ht.forEach { valuePtr in switch Z_TYPE_P(valuePtr) { case IS_STRING: print(\u0026#34;Found a string\u0026#34;) case IS_LONG: print(\u0026#34;Found an integer: \\(Z_LVAL_P(valuePtr))\u0026#34;) default: print(\u0026#34;Found another type\u0026#34;) } } Iterating Over Keys and Values# These methods are for when you need both the key and the value, such as when processing an associative array.\nHelper Type: PHPArrayKey# When iterating with keys, the key is provided as a PHPArrayKey enum. This allows you to safely handle both string and integer keys.\nDefinition:\npublic enum PHPArrayKey { case int(UInt) case string(UnsafeMutablePointer\u0026lt;zend_string\u0026gt;) } forEach (Key-Value)# This is the base key-value iterator. It yields the PHPArrayKey and the raw zval pointer for every element.\nSignature:\nfunc forEach(body: (PHPArrayKey, UnsafeMutablePointer\u0026lt;zval\u0026gt;) -\u0026gt; Void)Example:\nlet ht = Z_ARRVAL_P(phpArrayZval) ht.forEach { key, valuePtr in if case .string(let keyStr) = key, String(zendString: keyStr) == \u0026#34;my_key\u0026#34; { // Found the key \u0026#34;my_key\u0026#34;, now inspect its value if Z_TYPE_P(valuePtr) == IS_LONG { // ... } } } Specialized Key-Value Iterators# These are powerful overloads that provide both the key and a type-safe value, filtering the array for you.\nSignatures:\nfunc withEachString(body: (PHPArrayKey, String) -\u0026gt; Void) func withEachInt(body: (PHPArrayKey, Int) -\u0026gt; Void) func withEachDouble(body: (PHPArrayKey, Double) -\u0026gt; Void) func withEachObject\u0026lt;T: ZendObjectContainer\u0026gt;( ofType ce: UnsafeMutablePointer\u0026lt;zend_class_entry\u0026gt;?, as objectType: T.Type, body: (PHPArrayKey, UnsafeMutablePointer\u0026lt;T\u0026gt;) -\u0026gt; Void )Example:\n// Given a PHP array: $config = [\u0026#34;host\u0026#34; =\u0026gt; \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34; =\u0026gt; 8080]; let ht = Z_ARRVAL_P(configZval) var config = [String: Any]() // Use the specialized iterator for strings ht.withEachString { key, value in if case .string(let keyStr) = key { config[String(zendString: keyStr)!] = value } } // Use the specialized iterator for integers ht.withEachInt { key, value in if case .string(let keyStr) = key { config[String(zendString: keyStr)!] = value } } // config now holds [\u0026#34;host\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;: 8080]"},{"id":4,"href":"/SwiftPHP/guides/extension-basics/","title":"PHP Extension Basics","section":"Guides","content":"PHP Extension Basics# PHP has 4 configurations from source code to configuration. This means from the source code to the runtime, you have to compile your extension to match the following.\nZTS (Thread Safe) + Debug ZTS (Thread Safe) + Release NTS (Non-Thread Safe) + Debug NTS (Non-Thread Safe) + Release Do you need thread safety? PHP is ran a few different ways, if you are running this as a traditional web server setup, i.e Apache/Nginx and PHP-FPM then no you do not need thread safety. NTS (Non-thread safe) will run faster than ZTS since it wont have the thread context overhead. The times you\u0026rsquo;d want ZTS is when PHP is run inside, effectively embedded into the process and that process is multithreaded. Mod_PHP for Apache is a great example.\nIf you are using Swift\u0026rsquo;s concurrency you do not explicty need PHP\u0026rsquo;s thread-safe version, its only when PHP itself is accessing data between its instances across thread. So in Swift you can use threads, as long as you return to the main thread for the response back to PHP. If you are embedding PHP yourself, then it will be safer to assume you need thread safety.\nEntry Point# All PHP extensions require get_module as the way to bootstrap your native PHP extesion. However with Swift, no function is directly C ABI compatible unless you annotate the function with @_cdecl(\u0026quot;get_module\u0026quot;). This makes the functions ready to bootstrap your extension.\n@_cdecl(\u0026#34;get_module\u0026#34;) @MainActor func get_module() -\u0026gt; UnsafeMutablePointer\u0026lt;zend_module_entry\u0026gt; { //.... }Startup \u0026amp; Shutdown Functions# Each extension has the ability to register shutdown and startup functions. They execute in this order:\nglobals_ctor startup activate \u0026lt;?php Execute PHP Script ?\u0026gt; deactivate shutdown globals_dtor These are not required but allows you to work between instances of PHP runtimes (threads), or reject loading itself as an extension. You do need to annotate the functions with @_cdecl just like the entry point.\n@_cdecl(\u0026#34;zm_startup_raylib\u0026#34;) func zm_startup_raylib(type: Int32, module_number: Int32) -\u0026gt; Int32 { print(\u0026#34;zm_startup_raylib\u0026#34;) return Int32(SUCCESS.rawValue) } @_cdecl(\u0026#34;zm_shutdown_raylib\u0026#34;) func zm_shutdown_raylib(type: Int32, module_number: Int32) -\u0026gt; Int32 { print(\u0026#34;zm_shutdown_raylib\u0026#34;) return Int32(SUCCESS.rawValue) } @_cdecl(\u0026#34;zm_activate_raylib\u0026#34;) func zm_activate_raylib(type: Int32, module_number: Int32) -\u0026gt; Int32 { print(\u0026#34;zm_activate_raylib\u0026#34;) return Int32(SUCCESS.rawValue) } @_cdecl(\u0026#34;zm_deactivate_raylib\u0026#34;) func zm_deactivate_raylib(type: Int32, module_number: Int32) -\u0026gt; Int32 { print(\u0026#34;zm_deactivate_raylib\u0026#34;) return Int32(SUCCESS.rawValue) } @_cdecl(\u0026#34;zm_globals_ctor_raylib\u0026#34;) func zm_globals_ctor_raylib(pointer: UnsafeMutableRawPointer?) { print(\u0026#34;zm_globals_ctor_raylib\u0026#34;) let globals = pointer!.bindMemory(to: raylibGlobals.self, capacity: 1) globals.pointee.someGlobalVariable = 42 } @_cdecl(\u0026#34;zm_globals_dtor_raylib\u0026#34;) func zm_globals_dtor_raylib(pointer: UnsafeMutableRawPointer?) { print(\u0026#34;zm_globals_dtor_raylib\u0026#34;) // Optional cleanup code for globals }Zend Module Entry# Inside your get_module you need to construct a zend_module_entry and return it.\n#if ZTS raylibModule_ptr = create_module_entry( module_name, version, raylib_functions_ptr, zm_startup_raylib, zm_shutdown_raylib, zm_activate_raylib, zm_deactivate_raylib, zm_info_raylib, MemoryLayout\u0026lt;raylibGlobals\u0026gt;.size, \u0026amp;raylib_globals_id, zm_globals_ctor_raylib, zm_globals_dtor_raylib, build_id ) #else raylibModule_ptr = create_module_entry( module_name, version, raylib_functions_ptr, zm_startup_raylib, zm_shutdown_raylib, zm_activate_raylib, zm_deactivate_raylib, zm_info_raylib, MemoryLayout\u0026lt;raylibGlobals\u0026gt;.size, zm_globals_ctor_raylib, zm_globals_dtor_raylib, build_id ) #endifPHP, depending on how its going to be build has shifting structs and zend_module_entry is one of them where ZTS (thread-safe) extesions also need to register a globals_id. Here is the raw C struct declared in PHP-src:\nstruct _zend_module_entry { unsigned short size; unsigned int zend_api; unsigned char zend_debug; unsigned char zts; const struct _zend_ini_entry *ini_entry; const struct _zend_module_dep *deps; const char *name; const struct _zend_function_entry *functions; zend_result (*module_startup_func)(INIT_FUNC_ARGS); zend_result (*module_shutdown_func)(SHUTDOWN_FUNC_ARGS); zend_result (*request_startup_func)(INIT_FUNC_ARGS); zend_result (*request_shutdown_func)(SHUTDOWN_FUNC_ARGS); void (*info_func)(ZEND_MODULE_INFO_FUNC_ARGS); const char *version; size_t globals_size; #ifdef ZTS ts_rsrc_id* globals_id_ptr; #else void* globals_ptr; #endif void (*globals_ctor)(void *global); void (*globals_dtor)(void *global); zend_result (*post_deactivate_func)(void); int module_started; unsigned char type; void *handle; int module_number; const char *build_id; };"}]