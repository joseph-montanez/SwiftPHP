[{"id":0,"href":"/SwiftPHP/guides/","title":"Guides","section":"Hello Swift","content":"This is the main landing page for the guides section.\n"},{"id":1,"href":"/SwiftPHP/guides/installation/","title":"Installtion Guide","section":"Guides","content":"Installation Guide# As of writing, this is designed for PHP 8.4 support.\nInstalling on macOS# macOS is straight forward but requires brew and xcode installed.\nxcode-select --install /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; # Build PHP.xcframework to compile extensions against ./Scripts/build_xcframework.sh # Build PHP CLI to test your extension with ./Scripts/build_macos.shInstallation on Windows 11 x64/ARM64# As of this time, the current Windows SDK is broken and you need to follow the guide to install Swift on Windows successfully https://forums.swift.org/t/an-unofficial-guide-to-building-the-swift-toolchain-on-windows-x64-and-arm64/81751\nWindows 11 ARM64# PHP has no official support for Windows 11 on ARM, however progress is being made and you can use the guide below.\nDownload the experimental builds for PHP 8.4: https://github.com/hyh19962008/php-windows-arm64/releases/tag/8.4.10. Source code and Binary php-8.4.10-nts-Win32-vs17-arm64-experimental.7z Source code (zip) Copy php-src-php-8.4.10\\win32\\build\\config.w32.h.in to php-src-php-8.4.10\\php\\config.w32.h\nEdit Scripts\\win_ext.ps1 and change $env:PHP_SRC_ROOT=\u0026quot;D:/dev/php-src-php-8.4.10\u0026quot; to where the PHP source code was unzipped to.\n"},{"id":2,"href":"/SwiftPHP/guides/extension-basics/","title":"PHP Extension Basics","section":"Guides","content":"PHP Extension Basics# PHP has 4 configurations from source code to configuration. This means from the source code to the runtime, you have to compile your extension to match the following.\nZTS (Thread Safe) + Debug ZTS (Thread Safe) + Release NTS (Non-Thread Safe) + Debug NTS (Non-Thread Safe) + Release Do you need thread safety? PHP is ran a few different ways, if you are running this as a traditional web server setup, i.e Apache/Nginx and PHP-FPM then no you do not need thread safety. NTS (Non-thread safe) will run faster than ZTS since it wont have the thread context overhead. The times you\u0026rsquo;d want ZTS is when PHP is run inside, effectively embedded into the process and that process is multithreaded. Mod_PHP for Apache is a great example.\nIf you are using Swift\u0026rsquo;s concurrency you do not explicty need PHP\u0026rsquo;s thread-safe version, its only when PHP itself is accessing data between its instances across thread. So in Swift you can use threads, as long as you return to the main thread for the response back to PHP. If you are embedding PHP yourself, then it will be safer to assume you need thread safety.\nEntry Point# All PHP extensions require get_module as the way to bootstrap your native PHP extesion. However with Swift, no function is directly C ABI compatible unless you annotate the function with @_cdecl(\u0026quot;get_module\u0026quot;). This makes the functions ready to bootstrap your extension.\n@_cdecl(\u0026#34;get_module\u0026#34;) @MainActor func get_module() -\u0026gt; UnsafeMutablePointer\u0026lt;zend_module_entry\u0026gt; { //.... }Startup \u0026amp; Shutdown Functions# Each extension has the ability to register shutdown and startup functions. They execute in this order:\nglobals_ctor startup activate \u0026lt;?php Execute PHP Script ?\u0026gt; deactivate shutdown globals_dtor These are not required but allows you to work between instances of PHP runtimes (threads), or reject loading itself as an extension. You do need to annotate the functions with @_cdecl just like the entry point.\n@_cdecl(\u0026#34;zm_startup_raylib\u0026#34;) func zm_startup_raylib(type: Int32, module_number: Int32) -\u0026gt; Int32 { print(\u0026#34;zm_startup_raylib\u0026#34;) return Int32(SUCCESS.rawValue) } @_cdecl(\u0026#34;zm_shutdown_raylib\u0026#34;) func zm_shutdown_raylib(type: Int32, module_number: Int32) -\u0026gt; Int32 { print(\u0026#34;zm_shutdown_raylib\u0026#34;) return Int32(SUCCESS.rawValue) } @_cdecl(\u0026#34;zm_activate_raylib\u0026#34;) func zm_activate_raylib(type: Int32, module_number: Int32) -\u0026gt; Int32 { print(\u0026#34;zm_activate_raylib\u0026#34;) return Int32(SUCCESS.rawValue) } @_cdecl(\u0026#34;zm_deactivate_raylib\u0026#34;) func zm_deactivate_raylib(type: Int32, module_number: Int32) -\u0026gt; Int32 { print(\u0026#34;zm_deactivate_raylib\u0026#34;) return Int32(SUCCESS.rawValue) } @_cdecl(\u0026#34;zm_globals_ctor_raylib\u0026#34;) func zm_globals_ctor_raylib(pointer: UnsafeMutableRawPointer?) { print(\u0026#34;zm_globals_ctor_raylib\u0026#34;) let globals = pointer!.bindMemory(to: raylibGlobals.self, capacity: 1) globals.pointee.someGlobalVariable = 42 } @_cdecl(\u0026#34;zm_globals_dtor_raylib\u0026#34;) func zm_globals_dtor_raylib(pointer: UnsafeMutableRawPointer?) { print(\u0026#34;zm_globals_dtor_raylib\u0026#34;) // Optional cleanup code for globals }Zend Module Entry# Inside your get_module you need to construct a zend_module_entry and return it.\n#if ZTS raylibModule_ptr = create_module_entry( module_name, version, raylib_functions_ptr, zm_startup_raylib, zm_shutdown_raylib, zm_activate_raylib, zm_deactivate_raylib, zm_info_raylib, MemoryLayout\u0026lt;raylibGlobals\u0026gt;.size, \u0026amp;raylib_globals_id, zm_globals_ctor_raylib, zm_globals_dtor_raylib, build_id ) #else raylibModule_ptr = create_module_entry( module_name, version, raylib_functions_ptr, zm_startup_raylib, zm_shutdown_raylib, zm_activate_raylib, zm_deactivate_raylib, zm_info_raylib, MemoryLayout\u0026lt;raylibGlobals\u0026gt;.size, zm_globals_ctor_raylib, zm_globals_dtor_raylib, build_id ) #endifPHP, depending on how its going to be build has shifting structs and zend_module_entry is one of them where ZTS (thread-safe) extesions also need to register a globals_id. Here is the raw C struct declared in PHP-src:\nstruct _zend_module_entry { unsigned short size; unsigned int zend_api; unsigned char zend_debug; unsigned char zts; const struct _zend_ini_entry *ini_entry; const struct _zend_module_dep *deps; const char *name; const struct _zend_function_entry *functions; zend_result (*module_startup_func)(INIT_FUNC_ARGS); zend_result (*module_shutdown_func)(SHUTDOWN_FUNC_ARGS); zend_result (*request_startup_func)(INIT_FUNC_ARGS); zend_result (*request_shutdown_func)(SHUTDOWN_FUNC_ARGS); void (*info_func)(ZEND_MODULE_INFO_FUNC_ARGS); const char *version; size_t globals_size; #ifdef ZTS ts_rsrc_id* globals_id_ptr; #else void* globals_ptr; #endif void (*globals_ctor)(void *global); void (*globals_dtor)(void *global); zend_result (*post_deactivate_func)(void); int module_started; unsigned char type; void *handle; int module_number; const char *build_id; };"}]