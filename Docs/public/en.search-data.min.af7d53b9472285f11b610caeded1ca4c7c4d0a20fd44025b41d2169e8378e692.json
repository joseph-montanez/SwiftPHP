[{"id":0,"href":"/SwiftPHP/guides/","title":"Guides","section":"Hello Swift","content":"This is the main landing page for the guides section.\n"},{"id":1,"href":"/SwiftPHP/guides/installation/","title":"Installtion Guide","section":"Guides","content":"Installation Guide# As of writing, this is designed for PHP 8.4 support.\nInstalling on macOS# macOS is straight forward but requires brew and xcode installed.\nxcode-select --install /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; # Build PHP.xcframework to compile extensions against ./Scripts/build_xcframework.sh # Build PHP CLI to test your extension with ./Scripts/build_macos.shInstallation on Windows 11 x64/ARM64# As of this time, the current Windows SDK is broken and you need to follow the guide to install Swift on Windows successfully https://forums.swift.org/t/an-unofficial-guide-to-building-the-swift-toolchain-on-windows-x64-and-arm64/81751\nWindows 11 ARM64# PHP has no official support for Windows 11 on ARM, however progress is being made and you can use the guide below.\nDownload the experimental builds for PHP 8.4: https://github.com/hyh19962008/php-windows-arm64/releases/download/8.4.10/php-8.4.10-nts-Win32-vs17-arm64-experimental.7z. Source code and SDK are in the same 7zip file. php-8.4.10-nts-Win32-vs17-arm64-experimental.7z Edit Scripts/win_ext.ps1 and change $env:PHP_SRC_ROOT=\u0026quot;D:/dev/php-src-php-8.4.10\u0026quot; to where the PHP source code was unzipped to. # Change these to where you decompressed `php-8.4.10-nts-Win32-vs17-arm64-experimental` $env:PHP_SRC_ROOT = \u0026#34;D:/dev/php-8.4.10-nts-Win32-vs17-arm64-experimental/SDK/include\u0026#34; $env:PHP_LIB_ROOT = \u0026#34;D:/dev/php-8.4.10-nts-Win32-vs17-arm64-experimental/SDK/lib\u0026#34; Run Scripts/win_ext.ps1 to build your Native PHP extension. "},{"id":2,"href":"/SwiftPHP/guides/performance/","title":"Performance","section":"Guides","content":"Performance# Swift offers great performance since its a compiled language with parallel and async features that are type checked. All while having no garbage collection.\nBenchmark Pairwise Distance# Pairwise Distance calculates the distance between every unique pair of vectors\n$$d = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2 + (z_2 - z_1)^2}$$\nResult# Version Processor / OS Vector Count Pairwise Calculations Execution Time Estimated Time at 50 k Vectors Speedup vs PHP PHP (Baseline) Apple M4 Mac mini (macOS 15) 2 000 ~2 million ~1.47 s ~15.3 minutes 1× Swift (Single Core) Apple M4 Mac mini (macOS 15) 50 000 ~1.25 billion 29.30 s 29.30 s 30.99× Swift (Multi-Core) Apple M4 Mac mini (macOS 15) 50 000 ~1.25 billion 7.00 s 7.00 s 133.25× PHP (Baseline) Snapdragon X1P42100 (Windows 11) 2 000 ~2 million 1.7833 s ~18.6 minutes (estimated) 1× Swift (Multi-Core) Snapdragon X1P42100 (Windows 11) 50 000 ~1.25 billion 4.5609 s 4.5609 s ~234× PHP Benchmark Test# $numVectors = 50_000; echo \u0026#34;Generating test data...\\n\u0026#34;; $vectors = []; for ($i = 0; $i \u0026lt; $numVectors; $i++) { $vectors[] = new \\raylib\\Vector3( rand(0, 100) / 10.0, rand(0, 100) / 10.0, rand(0, 100) / 10.0 ); } echo \u0026#34;Test data generated.\\n\\n\u0026#34;; $smallVectorSet = array_slice($vectors, 0, 2000); printf(\u0026#34;\\n--- Benchmarking Pairwise Distance ---\\n\u0026#34;); printf(\u0026#34;Running PHP version with %s vectors...\\n\u0026#34;, number_format(count($smallVectorSet))); $startPhp = microtime(true); $phpDistance = php_total_pairwise_distance($smallVectorSet); $endPhp = microtime(true); $phpTime = $endPhp - $startPhp; printf(\u0026#34;PHP Time: %.4f seconds\\n\u0026#34;, $phpTime); printf(\u0026#34;\\nRunning Swift version with %s vectors...\\n\u0026#34;, number_format(count($vectors))); $startSwift = microtime(true); $swiftDistance = \\raylib\\total_pairwise_distance($vectors); // Your new namespaced function $endSwift = microtime(true); $swiftTime = $endSwift - $startSwift; printf(\u0026#34;Swift Time: %.4f seconds\\n\u0026#34;, $swiftTime); $speedup = ($phpTime / count($smallVectorSet)**2) / ($swiftTime / count($vectors)**2); printf(\u0026#34;\\n✅ Swift extension is roughly %.2f times faster on a per-operation basis.\\n\u0026#34;, $speedup);Pure PHP Implementation# PHP has no built-in threading or parallel features to speed this up.\n/** * Calculates the sum of the distances between every unique * pair of vectors in the array. This is an O(n^2) operation. */ function php_total_pairwise_distance(array $vectors): float { $totalDistance = 0.0; $count = count($vectors); for ($i = 0; $i \u0026lt; $count; $i++) { for ($j = $i + 1; $j \u0026lt; $count; $j++) { $dx = $vectors[$i]-\u0026gt;x - $vectors[$j]-\u0026gt;x; $dy = $vectors[$i]-\u0026gt;y - $vectors[$j]-\u0026gt;y; $dz = $vectors[$i]-\u0026gt;z - $vectors[$j]-\u0026gt;z; $totalDistance += sqrt($dx * $dx + $dy * $dy + $dz * $dz); } } return $totalDistance; }SwiftPHP Native PHP Extension Implementation# /** * A simple, thread-safe container to hold a single value. * * Why a class? * A class is a reference type, so we can pass an instance of it into a concurrent * Task and have that task modify the original object\u0026#39;s contents. * * Why final? * `final` tells the compiler that this class will never be subclassed. This is a * performance optimization, as it allows the compiler to use direct function * calls (static dispatch) instead of more complex dynamic dispatch. * * Why generic (`\u0026lt;T\u0026gt;`)? * This makes the box reusable. It can hold any type of value (a Double, * a String, a custom struct, etc.), not just the Double needed for this specific function. * * Why `@unchecked Sendable`? * `Sendable` is a protocol that marks a type as being safe to share across * concurrent threads. Classes are not `Sendable` by default because they represent * shared, mutable state, which is a primary source of data races. * `@unchecked` is a promise to the compiler: \u0026#34;I, the developer, guarantee that * I have made this class thread-safe myself.\u0026#34; The compiler will then trust us * and allow this object to be passed into a concurrent `Task`. */ final class ResultBox\u0026lt;T\u0026gt;: @unchecked Sendable { /// The value being stored. It\u0026#39;s private to ensure all access goes /// through our thread-safe `get()` and `set()` methods. It\u0026#39;s an optional /// because it starts with no value. private var value: T? /// The locking mechanism. `NSLock` is a basic mutex (mutal exclusion lock). /// It ensures that only one thread can be executing the code inside the /// locked section at any given time, preventing data races. private let lock = NSLock() /** * Safely sets the value from any thread. */ func set(_ value: T) { // Acquire the lock. If another thread already holds the lock, this // line will pause and wait until the lock is released. lock.lock() // `defer` is a powerful Swift feature. The code inside the `defer` block // is guaranteed to run at the end of the current scope (i.e., just // before the `set` function returns), no matter what happens. This // ensures the lock is *always* released, even if an error occurred. defer { lock.unlock() } // Now that we have the lock, it\u0026#39;s safe to modify the shared value. self.value = value } /** * Safely retrieves the value from any thread. */ func get() -\u0026gt; T? { lock.lock() defer { lock.unlock() } return self.value } } /** * Calculates the total pairwise distance in parallel. * * Why `async`? * This marks the function as asynchronous. It can perform long-running, concurrent * work without blocking the thread that calls it. The `await` keyword is used * to call it, which allows the system to suspend this function and run other * code while waiting for the parallel tasks to complete. */ func calculateTotalPairwiseDistanceParallel(vectors nativeVectors: [Vector3]) async -\u0026gt; Double { let count = nativeVectors.count // A simple guard to prevent trying to calculate with fewer than 2 vectors. guard count \u0026gt;= 2 else { return 0.0 } // Why `ProcessInfo`? // This dynamically queries the system for the number of active CPU cores. // This makes the code adaptive; it will use 4 cores on a 4-core machine, // and 16 cores on a 16-core machine, ensuring optimal performance. let processorCount = ProcessInfo.processInfo.activeProcessorCount // Why this math for `chunkSize`? // This is a standard integer math formula to divide a number of items (`count`) // into a number of groups (`processorCount`), correctly handling any remainders. // It ensures that all vectors are processed. let chunkSize = (count + processorCount - 1) / processorCount // Why `withTaskGroup`? // This is the primary tool in Swift for dynamic, structured concurrency. It // creates a scope where you can spin up multiple child tasks that run in // parallel. The `await` on this line ensures the function will not proceed // until *all* the tasks added to the `group` have completed. return await withTaskGroup(of: Double.self, returning: Double.self) { group in // This loop creates the work for each core. It doesn\u0026#39;t do the work itself. for i in stride(from: 0, to: count, by: chunkSize) { let end = min(i + chunkSize, count) let chunkRange = i..\u0026lt;end // Why `group.addTask`? // This submits a block of code (a closure) to the Swift Concurrency // runtime. The runtime will schedule this task to run on a background // thread, typically from a cooperative thread pool sized to the // number of CPU cores. group.addTask { // Why `localTotal`? // This is a critical pattern for parallelism. Each thread calculates // its own partial sum. This avoids having all threads trying to // update a single shared variable, which would require locking // and create a massive performance bottleneck (lock contention). var localTotal: Double = 0.0 // This is the actual \u0026#34;heavy lifting.\u0026#34; Each core processes its // assigned `chunkRange` of the outer loop. The inner loop remains // the same, but the overall work is now split across many cores. for i_inner in chunkRange { for j in (i_inner + 1)..\u0026lt;count { let dx = nativeVectors[i_inner].x - nativeVectors[j].x let dy = nativeVectors[i_inner].y - nativeVectors[j].y let dz = nativeVectors[i_inner].z - nativeVectors[j].z localTotal += sqrt(dx * dx + dy * dy + dz * dz) } } // Each task finishes and returns its own result to the group. return localTotal } } // Why `for await`? // This loop asynchronously waits for the child tasks in the group to // complete. As each task finishes and returns its `localTotal`, this // loop will receive the value. This is how results are collected. var finalTotal: Double = 0.0 for await partialResult in group { // The summation happens here, safely on the parent task\u0026#39;s thread, // after the parallel work is done. finalTotal += partialResult } return finalTotal } } // Why `@MainActor`? // This global constant is marked as belonging to the Main Actor. This is a // concurrency safety feature. It ensures that if this (or any other) global // state were ever modified, all access would be synchronized through the main // thread, preventing data races. For a `let` constant, it\u0026#39;s less critical // but is good practice. @MainActor public let arginfo_total_pairwise_distance: [zend_internal_arg_info] = [ // Describes the function itself to PHP\u0026#39;s reflection and error-handling systems. ZEND_BEGIN_ARG_INFO_EX( name: \u0026#34;total_pairwise_distance\u0026#34;, // The function name PHP sees return_reference: false, // The function returns a value, not a reference required_num_args: 1 // It must be called with at least 1 argument ), // Describes the first argument. ZEND_ARG_INFO( pass_by_ref: false, // The argument is passed by value name: \u0026#34;vectors\u0026#34; // The argument name is \u0026#34;vectors\u0026#34; ) ] // Why `@_cdecl`? // This attribute exposes the Swift function to the C world. It gives the // function a simple, predictable symbol name (\u0026#34;zif_total_pairwise_distance\u0026#34;) in the // compiled library file, which is what the PHP engine looks for when loading // the extension. \u0026#34;zif\u0026#34; stands for \u0026#34;Zend Internal Function\u0026#34;. @_cdecl(\u0026#34;zif_total_pairwise_distance\u0026#34;) public func zif_total_pairwise_distance( _ execute_data: UnsafeMutablePointer\u0026lt;zend_execute_data\u0026gt;?, _ return_value: UnsafeMutablePointer\u0026lt;zval\u0026gt;? ) { var vectorsParam: UnsafeMutablePointer\u0026lt;zval\u0026gt;? = nil guard let return_value = return_value else { return } // --- 1. Standard Parameter Parsing --- // This block uses the argument parsing API to safely extract the expected // array argument from PHP. If the user passes the wrong type or number of // arguments, this will fail gracefully and throw an error up to PHP. do { guard var state = ZEND_PARSE_PARAMETERS_START(min: 1, max: 1, execute_data: execute_data) else { return } try Z_PARAM_ARRAY(state: \u0026amp;state, dest: \u0026amp;vectorsParam) try ZEND_PARSE_PARAMETERS_END(state: state) } catch { return } guard let vectorsArrayZval = vectorsParam, let vector3_ce = V3State.shared.ce else { return } // --- 2. Copy PHP Objects into a Native Swift Array --- // This is the most important optimization for a parallel function. // Why copy? For two reasons: // 1. PERFORMANCE: Accessing data from PHP objects is slow and involves API // calls into the Zend Engine. Copying the raw data into a native Swift // array creates a tight, contiguous, cache-friendly block of memory. // This makes the billions of calculations in the parallel loop orders // of magnitude faster. // 2. THREAD SAFETY: PHP\u0026#39;s internal data structures are NOT safe to be // accessed by multiple threads simultaneously. Copying the data creates // a safe, isolated snapshot that our parallel Swift code can work on // without risk of crashing or corrupting the PHP engine. var nativeVectors: [Vector3] = [] let vectorHashTable = Z_ARRVAL_P(vectorsArrayZval) // Why `reserveCapacity`? // A small performance optimization. It pre-allocates enough memory for the // entire array at once, avoiding the overhead of resizing the array multiple // times as elements are appended. nativeVectors.reserveCapacity(Int(zend_hash_num_elements(vectorHashTable))) // `ZEND_HASH_FOREACH_VAL` is the Swift wrapper for iterating over a PHP array. ZEND_HASH_FOREACH_VAL(vectorHashTable) { vectorZval in // We verify that each item in the array is the correct object type. guard Z_TYPE_P(vectorZval) == IS_OBJECT, Z_OBJCE_P(vectorZval) == vector3_ce else { // In a real-world scenario, you might want to throw a PHP warning here. return } let intern = fetchObject(Z_OBJ_P(vectorZval)) // This is the fast, 24-byte memory copy. nativeVectors.append(intern.pointee.vector3) } // --- 3. The \u0026#34;Async-to-Sync\u0026#34; Bridge --- // This is the pattern used to call our `async` parallel function from this // synchronous C-style function. let resultBox = ResultBox\u0026lt;Double\u0026gt;() let semaphore = DispatchSemaphore(value: 0) // Why `Task`? // This kicks off the asynchronous work on a background thread pool. // The main thread (the one PHP is on) does not wait here; it continues on. Task { let distance = await calculateTotalPairwiseDistanceParallel(vectors: nativeVectors) resultBox.set(distance) // `signal()` tells the semaphore that the work is done, \u0026#34;waking up\u0026#34; // any thread that is waiting on it. semaphore.signal() } // Why `semaphore.wait()`? // This is the crucial blocking call. It PAUSES the main PHP thread right here // and waits until `semaphore.signal()` is called from the background task. // Without this, the function would return to PHP immediately with a zero // result, long before the calculation was finished. semaphore.wait() // --- 4. Return the Final Value to PHP --- // We safely retrieve the result from our thread-safe box. let finalDistance = resultBox.get() ?? 0.0 // `RETURN_DOUBLE` is a helper/macro that converts the Swift `Double` into // a PHP `zval` of type IS_DOUBLE and sets it as the function\u0026#39;s return value. RETURN_DOUBLE(return_value, finalDistance) }"},{"id":3,"href":"/SwiftPHP/guides/extension-basics/","title":"PHP Extension Basics","section":"Guides","content":"PHP Extension Basics# PHP has 4 configurations from source code to configuration. This means from the source code to the runtime, you have to compile your extension to match the following.\nZTS (Thread Safe) + Debug ZTS (Thread Safe) + Release NTS (Non-Thread Safe) + Debug NTS (Non-Thread Safe) + Release Do you need thread safety? PHP is ran a few different ways, if you are running this as a traditional web server setup, i.e Apache/Nginx and PHP-FPM then no you do not need thread safety. NTS (Non-thread safe) will run faster than ZTS since it wont have the thread context overhead. The times you\u0026rsquo;d want ZTS is when PHP is run inside, effectively embedded into the process and that process is multithreaded. Mod_PHP for Apache is a great example.\nIf you are using Swift\u0026rsquo;s concurrency you do not explicty need PHP\u0026rsquo;s thread-safe version, its only when PHP itself is accessing data between its instances across thread. So in Swift you can use threads, as long as you return to the main thread for the response back to PHP. If you are embedding PHP yourself, then it will be safer to assume you need thread safety.\nEntry Point# All PHP extensions require get_module as the way to bootstrap your native PHP extesion. However with Swift, no function is directly C ABI compatible unless you annotate the function with @_cdecl(\u0026quot;get_module\u0026quot;). This makes the functions ready to bootstrap your extension.\n@_cdecl(\u0026#34;get_module\u0026#34;) @MainActor func get_module() -\u0026gt; UnsafeMutablePointer\u0026lt;zend_module_entry\u0026gt; { //.... }Startup \u0026amp; Shutdown Functions# Each extension has the ability to register shutdown and startup functions. They execute in this order:\nglobals_ctor startup activate \u0026lt;?php Execute PHP Script ?\u0026gt; deactivate shutdown globals_dtor These are not required but allows you to work between instances of PHP runtimes (threads), or reject loading itself as an extension. You do need to annotate the functions with @_cdecl just like the entry point.\n@_cdecl(\u0026#34;zm_startup_raylib\u0026#34;) func zm_startup_raylib(type: Int32, module_number: Int32) -\u0026gt; Int32 { print(\u0026#34;zm_startup_raylib\u0026#34;) return Int32(SUCCESS.rawValue) } @_cdecl(\u0026#34;zm_shutdown_raylib\u0026#34;) func zm_shutdown_raylib(type: Int32, module_number: Int32) -\u0026gt; Int32 { print(\u0026#34;zm_shutdown_raylib\u0026#34;) return Int32(SUCCESS.rawValue) } @_cdecl(\u0026#34;zm_activate_raylib\u0026#34;) func zm_activate_raylib(type: Int32, module_number: Int32) -\u0026gt; Int32 { print(\u0026#34;zm_activate_raylib\u0026#34;) return Int32(SUCCESS.rawValue) } @_cdecl(\u0026#34;zm_deactivate_raylib\u0026#34;) func zm_deactivate_raylib(type: Int32, module_number: Int32) -\u0026gt; Int32 { print(\u0026#34;zm_deactivate_raylib\u0026#34;) return Int32(SUCCESS.rawValue) } @_cdecl(\u0026#34;zm_globals_ctor_raylib\u0026#34;) func zm_globals_ctor_raylib(pointer: UnsafeMutableRawPointer?) { print(\u0026#34;zm_globals_ctor_raylib\u0026#34;) let globals = pointer!.bindMemory(to: raylibGlobals.self, capacity: 1) globals.pointee.someGlobalVariable = 42 } @_cdecl(\u0026#34;zm_globals_dtor_raylib\u0026#34;) func zm_globals_dtor_raylib(pointer: UnsafeMutableRawPointer?) { print(\u0026#34;zm_globals_dtor_raylib\u0026#34;) // Optional cleanup code for globals }Zend Module Entry# Inside your get_module you need to construct a zend_module_entry and return it.\n#if ZTS raylibModule_ptr = create_module_entry( module_name, version, raylib_functions_ptr, zm_startup_raylib, zm_shutdown_raylib, zm_activate_raylib, zm_deactivate_raylib, zm_info_raylib, MemoryLayout\u0026lt;raylibGlobals\u0026gt;.size, \u0026amp;raylib_globals_id, zm_globals_ctor_raylib, zm_globals_dtor_raylib, build_id ) #else raylibModule_ptr = create_module_entry( module_name, version, raylib_functions_ptr, zm_startup_raylib, zm_shutdown_raylib, zm_activate_raylib, zm_deactivate_raylib, zm_info_raylib, MemoryLayout\u0026lt;raylibGlobals\u0026gt;.size, zm_globals_ctor_raylib, zm_globals_dtor_raylib, build_id ) #endifPHP, depending on how its going to be build has shifting structs and zend_module_entry is one of them where ZTS (thread-safe) extesions also need to register a globals_id. Here is the raw C struct declared in PHP-src:\nstruct _zend_module_entry { unsigned short size; unsigned int zend_api; unsigned char zend_debug; unsigned char zts; const struct _zend_ini_entry *ini_entry; const struct _zend_module_dep *deps; const char *name; const struct _zend_function_entry *functions; zend_result (*module_startup_func)(INIT_FUNC_ARGS); zend_result (*module_shutdown_func)(SHUTDOWN_FUNC_ARGS); zend_result (*request_startup_func)(INIT_FUNC_ARGS); zend_result (*request_shutdown_func)(SHUTDOWN_FUNC_ARGS); void (*info_func)(ZEND_MODULE_INFO_FUNC_ARGS); const char *version; size_t globals_size; #ifdef ZTS ts_rsrc_id* globals_id_ptr; #else void* globals_ptr; #endif void (*globals_ctor)(void *global); void (*globals_dtor)(void *global); zend_result (*post_deactivate_func)(void); int module_started; unsigned char type; void *handle; int module_number; const char *build_id; };"}]