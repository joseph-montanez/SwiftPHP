<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/SwiftPHP/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=SwiftPHP/livereload" data-no-instant defer></script>
  <!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Performance Comparison#
Swift offers great performance since its a compiled language with parallel and async features that are type checked. All while having no garbage collection.
Benchmark Pairwise Distance#
Pairwise Distance calculates the distance between every unique pair of vectors
$$d = \sqrt{(x_2 - x_1)^2 &#43; (y_2 - y_1)^2 &#43; (z_2 - z_1)^2}$$
Result (Debug Mode)#
The following is based on 50,000 vectors and ~1.25 billion calcuations.

  
      
          Version
          Processor / OS
          Execution Time
          Estimated Time at 50 k Vectors
          Speedup vs PHP
      
  
  
      
          PHP (Baseline)
          Apple M4 Mac mini (macOS 15)
          953.98 s
          ~15.9 minutes
          1×
      
      
          Swift (Single Core)
          Apple M4 Mac mini (macOS 15)
          8.2841 s
          8.2841 s
          ~115.16×
      
      
          Swift (Multi-Core)
          Apple M4 Mac mini (macOS 15)
          2.1486 s
          2.1486 s
          ~444.00×
      
      
          PHP (Baseline)
          Snapdragon X1P42100 (Windows 11)
          1.2340 s
          ~12.9 minutes
          1×
      
      
          Swift (Single Core)
          Snapdragon X1P42100 (Windows 11)
          11.0950 s
          11.0950 s
          ~68.35×
      
      
          Swift (Multi-Core)
          Snapdragon X1P42100 (Windows 11)
          3.0551 s
          3.0551 s
          ~252.45×
      
  

PHP Benchmark Test#
$numVectors = 50_000;

echo &#34;Generating test data...\n&#34;;
$vectors = [];
for ($i = 0; $i &lt; $numVectors; $i&#43;&#43;) {
    $vectors[] = new \raylib\Vector3(
        rand(0, 100) / 10.0,
        rand(0, 100) / 10.0,
        rand(0, 100) / 10.0
    );
}
echo &#34;Test data generated.\n\n&#34;;



$smallVectorSet = array_slice($vectors, 0, 2000);

printf(&#34;\n--- Benchmarking Pairwise Distance ---\n&#34;);
printf(&#34;Running PHP version with %s vectors...\n&#34;, number_format(count($smallVectorSet)));
$startPhp = microtime(true);
$phpDistance = php_total_pairwise_distance($smallVectorSet);
$endPhp = microtime(true);
$phpTime = $endPhp - $startPhp;
printf(&#34;PHP Time: %.4f seconds\n&#34;, $phpTime);


printf(&#34;\nRunning Swift version with %s vectors...\n&#34;, number_format(count($vectors)));
$startSwift = microtime(true);
$swiftDistance = \raylib\total_pairwise_distance($vectors); // Your new namespaced function
$endSwift = microtime(true);
$swiftTime = $endSwift - $startSwift;
printf(&#34;Swift Time: %.4f seconds\n&#34;, $swiftTime);

$speedup = ($phpTime / count($smallVectorSet)**2) / ($swiftTime / count($vectors)**2);
printf(&#34;\n✅ Swift extension is roughly %.2f times faster on a per-operation basis.\n&#34;, $speedup);Pure PHP Implementation#
PHP has no built-in threading or parallel features to speed this up.">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/SwiftPHP/guides/performance/">
  <meta property="og:site_name" content="PHP Extensions in Swift">
  <meta property="og:title" content="Performance Comparison">
  <meta property="og:description" content="Performance Comparison# Swift offers great performance since its a compiled language with parallel and async features that are type checked. All while having no garbage collection.
Benchmark Pairwise Distance# Pairwise Distance calculates the distance between every unique pair of vectors
$$d = \sqrt{(x_2 - x_1)^2 &#43; (y_2 - y_1)^2 &#43; (z_2 - z_1)^2}$$
Result (Debug Mode)# The following is based on 50,000 vectors and ~1.25 billion calcuations.
Version Processor / OS Execution Time Estimated Time at 50 k Vectors Speedup vs PHP PHP (Baseline) Apple M4 Mac mini (macOS 15) 953.98 s ~15.9 minutes 1× Swift (Single Core) Apple M4 Mac mini (macOS 15) 8.2841 s 8.2841 s ~115.16× Swift (Multi-Core) Apple M4 Mac mini (macOS 15) 2.1486 s 2.1486 s ~444.00× PHP (Baseline) Snapdragon X1P42100 (Windows 11) 1.2340 s ~12.9 minutes 1× Swift (Single Core) Snapdragon X1P42100 (Windows 11) 11.0950 s 11.0950 s ~68.35× Swift (Multi-Core) Snapdragon X1P42100 (Windows 11) 3.0551 s 3.0551 s ~252.45× PHP Benchmark Test# $numVectors = 50_000; echo &#34;Generating test data...\n&#34;; $vectors = []; for ($i = 0; $i &lt; $numVectors; $i&#43;&#43;) { $vectors[] = new \raylib\Vector3( rand(0, 100) / 10.0, rand(0, 100) / 10.0, rand(0, 100) / 10.0 ); } echo &#34;Test data generated.\n\n&#34;; $smallVectorSet = array_slice($vectors, 0, 2000); printf(&#34;\n--- Benchmarking Pairwise Distance ---\n&#34;); printf(&#34;Running PHP version with %s vectors...\n&#34;, number_format(count($smallVectorSet))); $startPhp = microtime(true); $phpDistance = php_total_pairwise_distance($smallVectorSet); $endPhp = microtime(true); $phpTime = $endPhp - $startPhp; printf(&#34;PHP Time: %.4f seconds\n&#34;, $phpTime); printf(&#34;\nRunning Swift version with %s vectors...\n&#34;, number_format(count($vectors))); $startSwift = microtime(true); $swiftDistance = \raylib\total_pairwise_distance($vectors); // Your new namespaced function $endSwift = microtime(true); $swiftTime = $endSwift - $startSwift; printf(&#34;Swift Time: %.4f seconds\n&#34;, $swiftTime); $speedup = ($phpTime / count($smallVectorSet)**2) / ($swiftTime / count($vectors)**2); printf(&#34;\n✅ Swift extension is roughly %.2f times faster on a per-operation basis.\n&#34;, $speedup);Pure PHP Implementation# PHP has no built-in threading or parallel features to speed this up.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="guides">
<title>Performance Comparison | PHP Extensions in Swift</title>
<link rel="icon" href="/SwiftPHP/favicon.png" >
<link rel="manifest" href="/SwiftPHP/manifest.json">
<link rel="canonical" href="http://localhost:1313/SwiftPHP/guides/performance/">
<link rel="stylesheet" href="/SwiftPHP/book.min.d124d6c76b11546b04023ef152f0ca77dd5bfd00e1638c75250d60e274cdc189.css" integrity="sha256-0STWx2sRVGsEAj7xUvDKd91b/QDhY4x1JQ1g4nTNwYk=" crossorigin="anonymous">


  <script defer src="/SwiftPHP/fuse.min.js"></script>
  <script defer src="/SwiftPHP/en.search.min.70d4126c3d21891f0879b9d17a2d421597ba5bc49c3a2c0a8b9d1f77ca029508.js" integrity="sha256-cNQSbD0hiR8IebnRei1CFZe6W8ScOiwKi50fd8oClQg=" crossorigin="anonymous"></script>

     
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" crossorigin="anonymous"
    onload="renderMathInElement(document.body, {
        delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
        ]
    });">
</script>
  
</head>
<body dir="ltr" class="book-kind-page book-type-guides">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    
<aside class="book-menu">
  <div class="book-menu-content">
    
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/SwiftPHP/"><img src="/SwiftPHP/swiftphp-logo.svg" alt="Logo" /><span>PHP Extensions in Swift</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>












  



  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/SwiftPHP/guides/" class="">
      Guides</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/SwiftPHP/guides/installation/" class="">
      Installtion Guide</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SwiftPHP/guides/performance/" class="active">
      Performance Comparison</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SwiftPHP/guides/arrays/" class="">
      PHP Arrays In Swift</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SwiftPHP/guides/extension-basics/" class="">
      PHP Extension Basics</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>













</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>



  </div>
</aside>
 

    <div class="book-page">
      <header class="book-header hidden">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/SwiftPHP/icons/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Performance Comparison</h3>

  <label for="toc-control">
    
    <img src="/SwiftPHP/icons/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#benchmark-pairwise-distance">Benchmark Pairwise Distance</a>
      <ul>
        <li><a href="#result-debug-mode">Result (Debug Mode)</a></li>
        <li><a href="#php-benchmark-test">PHP Benchmark Test</a></li>
        <li><a href="#pure-php-implementation">Pure PHP Implementation</a></li>
        <li><a href="#swiftphp-native-php-extension-implementation">SwiftPHP Native PHP Extension Implementation</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="performance-comparison">Performance Comparison<a class="anchor" href="#performance-comparison">#</a></h1>
<p>Swift offers great performance since its a compiled language with parallel and async features that are type checked. All while having no garbage collection.</p>
<h2 id="benchmark-pairwise-distance">Benchmark Pairwise Distance<a class="anchor" href="#benchmark-pairwise-distance">#</a></h2>
<p>Pairwise Distance calculates the distance between every unique pair of vectors</p>
<p>$$d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2 + (z_2 - z_1)^2}$$</p>
<h3 id="result-debug-mode">Result (Debug Mode)<a class="anchor" href="#result-debug-mode">#</a></h3>
<p>The following is based on 50,000 vectors and ~1.25 billion calcuations.</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">Version</th>
          <th style="text-align: left">Processor / OS</th>
          <th style="text-align: left">Execution Time</th>
          <th style="text-align: left">Estimated Time at 50 k Vectors</th>
          <th style="text-align: left">Speedup vs PHP</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>PHP (Baseline)</strong></td>
          <td style="text-align: left">Apple M4 Mac mini (macOS 15)</td>
          <td style="text-align: left">953.98 s</td>
          <td style="text-align: left"><strong>~15.9 minutes</strong></td>
          <td style="text-align: left">1×</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>Swift (Single Core)</strong></td>
          <td style="text-align: left">Apple M4 Mac mini (macOS 15)</td>
          <td style="text-align: left">8.2841 s</td>
          <td style="text-align: left">8.2841 s</td>
          <td style="text-align: left"><strong>~115.16×</strong></td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>Swift (Multi-Core)</strong></td>
          <td style="text-align: left">Apple M4 Mac mini (macOS 15)</td>
          <td style="text-align: left">2.1486 s</td>
          <td style="text-align: left">2.1486 s</td>
          <td style="text-align: left"><strong>~444.00×</strong></td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>PHP (Baseline)</strong></td>
          <td style="text-align: left">Snapdragon X1P42100 (Windows 11)</td>
          <td style="text-align: left">1.2340 s</td>
          <td style="text-align: left"><strong>~12.9 minutes</strong></td>
          <td style="text-align: left">1×</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>Swift (Single Core)</strong></td>
          <td style="text-align: left">Snapdragon X1P42100 (Windows 11)</td>
          <td style="text-align: left">11.0950 s</td>
          <td style="text-align: left">11.0950 s</td>
          <td style="text-align: left"><strong>~68.35×</strong></td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>Swift (Multi-Core)</strong></td>
          <td style="text-align: left">Snapdragon X1P42100 (Windows 11)</td>
          <td style="text-align: left">3.0551 s</td>
          <td style="text-align: left">3.0551 s</td>
          <td style="text-align: left"><strong>~252.45×</strong></td>
      </tr>
  </tbody>
</table>
<h3 id="php-benchmark-test">PHP Benchmark Test<a class="anchor" href="#php-benchmark-test">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-php" data-lang="php"><span style="display:flex;"><span>$numVectors <span style="color:#f92672">=</span> <span style="color:#ae81ff">50_000</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#34;Generating test data...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>$vectors <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> ($i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $i <span style="color:#f92672">&lt;</span> $numVectors; $i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    $vectors[] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">\raylib\Vector3</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">rand</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">100</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">10.0</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">rand</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">100</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">10.0</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">rand</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">100</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">10.0</span>
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#34;Test data generated.</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$smallVectorSet <span style="color:#f92672">=</span> <span style="color:#a6e22e">array_slice</span>($vectors, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2000</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">--- Benchmarking Pairwise Distance ---</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Running PHP version with %s vectors...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">number_format</span>(<span style="color:#a6e22e">count</span>($smallVectorSet)));
</span></span><span style="display:flex;"><span>$startPhp <span style="color:#f92672">=</span> <span style="color:#a6e22e">microtime</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>$phpDistance <span style="color:#f92672">=</span> <span style="color:#a6e22e">php_total_pairwise_distance</span>($smallVectorSet);
</span></span><span style="display:flex;"><span>$endPhp <span style="color:#f92672">=</span> <span style="color:#a6e22e">microtime</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>$phpTime <span style="color:#f92672">=</span> $endPhp <span style="color:#f92672">-</span> $startPhp;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;PHP Time: %.4f seconds</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, $phpTime);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Running Swift version with %s vectors...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">number_format</span>(<span style="color:#a6e22e">count</span>($vectors)));
</span></span><span style="display:flex;"><span>$startSwift <span style="color:#f92672">=</span> <span style="color:#a6e22e">microtime</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>$swiftDistance <span style="color:#f92672">=</span> <span style="color:#a6e22e">\raylib\total_pairwise_distance</span>($vectors); <span style="color:#75715e">// Your new namespaced function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>$endSwift <span style="color:#f92672">=</span> <span style="color:#a6e22e">microtime</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>$swiftTime <span style="color:#f92672">=</span> $endSwift <span style="color:#f92672">-</span> $startSwift;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Swift Time: %.4f seconds</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, $swiftTime);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$speedup <span style="color:#f92672">=</span> ($phpTime <span style="color:#f92672">/</span> <span style="color:#a6e22e">count</span>($smallVectorSet)<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>) <span style="color:#f92672">/</span> ($swiftTime <span style="color:#f92672">/</span> <span style="color:#a6e22e">count</span>($vectors)<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">✅ Swift extension is roughly %.2f times faster on a per-operation basis.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, $speedup);</span></span></code></pre></div><h3 id="pure-php-implementation">Pure PHP Implementation<a class="anchor" href="#pure-php-implementation">#</a></h3>
<p>PHP has no built-in threading or parallel features to speed this up.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-php" data-lang="php"><span style="display:flex;"><span><span style="color:#e6db74">/**
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * Calculates the sum of the distances between every unique 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * pair of vectors in the array. This is an O(n^2) operation.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">php_total_pairwise_distance</span>(<span style="color:#66d9ef">array</span> $vectors)<span style="color:#f92672">:</span> <span style="color:#a6e22e">float</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    $totalDistance <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>    $count <span style="color:#f92672">=</span> <span style="color:#a6e22e">count</span>($vectors);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> ($i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $i <span style="color:#f92672">&lt;</span> $count; $i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> ($j <span style="color:#f92672">=</span> $i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; $j <span style="color:#f92672">&lt;</span> $count; $j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            $dx <span style="color:#f92672">=</span> $vectors[$i]<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> $vectors[$j]<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>            $dy <span style="color:#f92672">=</span> $vectors[$i]<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">y</span> <span style="color:#f92672">-</span> $vectors[$j]<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">y</span>;
</span></span><span style="display:flex;"><span>            $dz <span style="color:#f92672">=</span> $vectors[$i]<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">z</span> <span style="color:#f92672">-</span> $vectors[$j]<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">z</span>;
</span></span><span style="display:flex;"><span>            $totalDistance <span style="color:#f92672">+=</span> <span style="color:#a6e22e">sqrt</span>($dx <span style="color:#f92672">*</span> $dx <span style="color:#f92672">+</span> $dy <span style="color:#f92672">*</span> $dy <span style="color:#f92672">+</span> $dz <span style="color:#f92672">*</span> $dz);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> $totalDistance;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h3 id="swiftphp-native-php-extension-implementation">SwiftPHP Native PHP Extension Implementation<a class="anchor" href="#swiftphp-native-php-extension-implementation">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * A highly optimized function to distribute N items into P parts as evenly as possible.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Why `@inline(__always)`?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * This is an aggressive compiler optimization directive. It tells the compiler to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * copy and paste the machine code for this function directly into the place
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * where it&#39;s called, rather than making a traditional function call. This eliminates
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * the tiny but measurable overhead of setting up a function call (pushing arguments
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * onto the stack, jumping to a new memory address, and returning). For a small,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * frequently-called function like this, inlining provides a speed boost.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>@inline(__always)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">chunkBounds</span>(count: Int, parts: Int, index: Int) -&gt; Range&lt;Int&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Why this math? This is a classic, highly efficient way to partition work.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// It avoids floating-point math and ensures perfect distribution.</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// `base`: The minimum number of items each part will handle.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// e.g., 100 items / 8 parts = 12. Each part gets at least 12.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> base = count <span style="color:#f92672">/</span> parts
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// `rem`: The number of &#34;leftover&#34; items that need to be distributed.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// e.g., 100 % 8 = 4. There are 4 extra items to hand out.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> rem = count <span style="color:#f92672">%</span> parts
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// `start`: The starting index for the current part (`index`).</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Each part gets `index * base` items from the base distribution.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// `min(index, rem)` is the clever part: it gives one extra &#34;leftover&#34; item</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// to each of the first `rem` parts.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// e.g., part 3 (index=3) gets 3*12 + min(3, 4) = 36 + 3 = 39.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> start = index <span style="color:#f92672">*</span> base <span style="color:#f92672">+</span> min(index, rem)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// `end`: The exclusive ending index.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// It&#39;s the `start` plus the `base` size, plus 1 if this part is one of the</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// first `rem` parts that received an extra item. This ensures the range</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// has the correct length.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> end = start <span style="color:#f92672">+</span> base <span style="color:#f92672">+</span> (index <span style="color:#f92672">&lt;</span> rem ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> start..&lt;end
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * A simple, raw pointer container.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Why a struct?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Structs are value types in Swift, meaning they are typically stack-allocated
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * and copied on assignment. This makes them very fast and lightweight. Here, it&#39;s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * just a thin wrapper around a raw pointer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Why `@unchecked Sendable`?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * This is a promise to the compiler that we, the developers, guarantee this type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * is safe to use across concurrent threads. We can make this promise because we
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * know each thread will only ever write to its own unique index (`partials.base[part]`),
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * so there will be no data races. This bypasses compiler safety checks for a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * performance gain.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Why `UnsafeMutablePointer`?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * This is the &#34;bare metal&#34; way to access memory in Swift. It&#39;s a raw memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * address, similar to a `double*` in C. It provides maximum performance by
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * bypassing all of Swift&#39;s safety features:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * - No automatic reference counting (ARC).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * - No bounds checking on access.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * - No memory lifetime management.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * We are responsible for allocating, initializing, and deallocating the memory manually.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Partials</span>: @unchecked Sendable { <span style="color:#66d9ef">let</span> base: UnsafeMutablePointer&lt;Double&gt; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Calculates the total pairwise distance using a low-level, highly optimized parallel approach.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">calculateTotalPairwiseDistanceParallel</span>(<span style="color:#66d9ef">_</span> vectors: [Vector3]) -&gt; Double {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> n = vectors.count
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span> { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Why `max(1, ...)`? A simple guard to prevent dividing by zero if the system</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// somehow reported zero cores.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> cores = max(<span style="color:#ae81ff">1</span>, ProcessInfo.processInfo.activeProcessorCount)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Why `min(cores, n)`? An optimization to avoid creating more threads than</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// there are items to process in the outer loop, which would be wasteful.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> parts = min(cores, n)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// --- Manual Memory Management ---</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 1. Allocate: We ask the system for a raw, uninitialized block of memory</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//    large enough to hold a `Double` for each parallel part.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> ptr = UnsafeMutablePointer&lt;Double&gt;.allocate(capacity: parts)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 2. Initialize: We explicitly set the allocated memory to a known state (all zeros).</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//    Accessing uninitialized memory is undefined behavior.</span>
</span></span><span style="display:flex;"><span>    ptr.initialize(repeating: <span style="color:#ae81ff">0</span>, count: parts)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create our thin wrapper around the raw pointer.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> partials = Partials(base: ptr)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Why `DispatchQueue.concurrentPerform`?</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// This is the star of the show. It&#39;s a highly optimized GCD function</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// specifically for &#34;fork-join&#34; parallelism. It executes the code in its closure</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// `iterations` times, distributing those executions across all available CPU</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// cores. Crucially, it is a *blocking* call: this line of code will not</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// finish and the function will not proceed until all `parts` have completed.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// This avoids the massive overhead of an async-to-sync bridge (like a DispatchSemaphore).</span>
</span></span><span style="display:flex;"><span>    DispatchQueue.concurrentPerform(iterations: parts) { part <span style="color:#66d9ef">in</span> <span style="color:#75715e">// `part` is the current iteration index (0, 1, 2, ...)</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Each thread calculates its assigned range of the outer loop.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> r = chunkBounds(count: n, parts: parts, index: part)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Why `local`? This is a critical performance pattern. Each thread accumulates</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// its own sub-total in a variable that is local to its own stack. This means</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// there is zero lock contention or synchronization needed during the main calculation.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> local: Double = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> i = r.lowerBound
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;</span> r.upperBound {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> a = vectors[i]
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// The inner loop still has to go to the end of the array. The parallelism</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// is only applied to the outer loop.</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> j = i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> j <span style="color:#f92672">&lt;</span> n {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> b = vectors[j]
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> dx = a.x <span style="color:#f92672">-</span> b.x
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> dy = a.y <span style="color:#f92672">-</span> b.y
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> dz = a.z <span style="color:#f92672">-</span> b.z
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// `squareRoot()` on a `Double` is often faster than the global `sqrt()` function.</span>
</span></span><span style="display:flex;"><span>                local <span style="color:#f92672">+=</span> (dx<span style="color:#f92672">*</span>dx <span style="color:#f92672">+</span> dy<span style="color:#f92672">*</span>dy <span style="color:#f92672">+</span> dz<span style="color:#f92672">*</span>dz).squareRoot()
</span></span><span style="display:flex;"><span>                j <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// After all calculations are done, each thread performs a single,</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// uncontested write to its designated slot in the shared memory block.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// e.g., thread 0 writes to base[0], thread 1 writes to base[1], etc.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Since no two threads write to the same index, no locks are needed.</span>
</span></span><span style="display:flex;"><span>        partials.base[part] = local
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// --- Final Summation and Cleanup ---</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// At this point, `concurrentPerform` has finished and all threads have completed.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The `partials.base` pointer now holds all the sub-totals.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> total: Double = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0.</span>.&lt;parts { total <span style="color:#f92672">+=</span> partials.base[i] }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 3. Deinitialize: We tell Swift that we are done with the values in this memory.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//    This is important for types that might have their own cleanup code. For `Double`,</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//    it&#39;s less critical but is correct and required practice.</span>
</span></span><span style="display:flex;"><span>    partials.base.deinitialize(count: parts)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 4. Deallocate: We return the raw memory block back to the system to prevent a memory leak.</span>
</span></span><span style="display:flex;"><span>    partials.base.deallocate()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> total
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The PHP C-interop code remains the same, as its job is to prepare the native</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Swift array and then call the calculation function.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@MainActor
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">let</span> arginfo_total_pairwise_distance: [zend_internal_arg_info] = [
</span></span><span style="display:flex;"><span>    ZEND_BEGIN_ARG_INFO_EX(name: <span style="color:#e6db74">&#34;total_pairwise_distance&#34;</span>, return_reference: <span style="color:#66d9ef">false</span>, required_num_args: <span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>    ZEND_ARG_INFO(pass_by_ref: <span style="color:#66d9ef">false</span>, name: <span style="color:#e6db74">&#34;vectors&#34;</span>)
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@_cdecl(<span style="color:#e6db74">&#34;zif_total_pairwise_distance&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">zif_total_pairwise_distance</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">_</span> execute_data: UnsafeMutablePointer&lt;zend_execute_data&gt;?,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">_</span> return_value: UnsafeMutablePointer&lt;zval&gt;?
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> vectorsParam: UnsafeMutablePointer&lt;zval&gt;? = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">guard</span> <span style="color:#66d9ef">let</span> return_value = return_value <span style="color:#66d9ef">else</span> { <span style="color:#66d9ef">return</span> }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">guard</span> <span style="color:#66d9ef">var</span> state = ZEND_PARSE_PARAMETERS_START(min: <span style="color:#ae81ff">1</span>, max: <span style="color:#ae81ff">1</span>, execute_data: execute_data) <span style="color:#66d9ef">else</span> { <span style="color:#66d9ef">return</span> }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> Z_PARAM_ARRAY(state: &amp;state, dest: &amp;vectorsParam)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> ZEND_PARSE_PARAMETERS_END(state: state)
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> { <span style="color:#66d9ef">return</span> }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">guard</span> <span style="color:#66d9ef">let</span> vectorsArrayZval = vectorsParam, <span style="color:#66d9ef">let</span> vector3_ce = V3State.shared.ce <span style="color:#66d9ef">else</span> { <span style="color:#66d9ef">return</span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> nativeVectors: [Vector3] = []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> ht = Z_ARRVAL_P(vectorsArrayZval)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> expectedCount = Int(zend_hash_num_elements(ht))
</span></span><span style="display:flex;"><span>    nativeVectors.reserveCapacity(expectedCount)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ZEND_HASH_FOREACH_VAL(ht) { zv <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> tmp = zval()
</span></span><span style="display:flex;"><span>        ZVAL_COPY_DEREF(&amp;tmp, zv)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">defer</span> { zval_ptr_dtor(&amp;tmp) }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> Z_TYPE(tmp) == IS_OBJECT <span style="color:#f92672">&amp;&amp;</span> Z_OBJCE(tmp) == vector3_ce {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> intern = fetchObject(Z_OBJ(tmp))
</span></span><span style="display:flex;"><span>            nativeVectors.append(intern.pointee.vector3)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// This is a direct, synchronous call. The function blocks until the parallel</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// work is done and then returns the final result. No bridging is needed.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> finalDistance = calculateTotalPairwiseDistanceParallel(nativeVectors)
</span></span><span style="display:flex;"><span>    RETURN_DOUBLE(return_value, finalDistance)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">

<div>

</div>

<div>

</div>

</div>



  



  
  
  
  <div class="flex flex-wrap justify-between">
    <span>
    
      <a href="/SwiftPHP/guides/installation/" class="flex align-center">
        <img src="/SwiftPHP/icons/backward.svg" class="book-icon" alt="Previous" title="Installtion Guide" />
        <span>Installtion Guide</span>
      </a>
    
    </span>
    <span>
    
      <a href="/SwiftPHP/guides/arrays/" class="flex align-center">
        <span>PHP Arrays In Swift</span>
        <img src="/SwiftPHP/icons/forward.svg" class="book-icon" alt="Next" title="PHP Arrays In Swift" />
      </a>
    
    </span>
  </div>
  




  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
  
  <div class="book-comments">

</div>
  
 
        
        

 
      </footer>

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    

<aside class="book-toc">
  <div class="book-toc-content">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#benchmark-pairwise-distance">Benchmark Pairwise Distance</a>
      <ul>
        <li><a href="#result-debug-mode">Result (Debug Mode)</a></li>
        <li><a href="#php-benchmark-test">PHP Benchmark Test</a></li>
        <li><a href="#pure-php-implementation">Pure PHP Implementation</a></li>
        <li><a href="#swiftphp-native-php-extension-implementation">SwiftPHP Native PHP Extension Implementation</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </div>
</aside>

 
  </main>

  
</body>
</html>


















